from celery import Celery
import logging
import sys
import pathlib
import io
import datetime


# temporary fix for importing module problems
# TODO change background tasks to module
pathRoot = pathlib.Path(__file__).parents[1]
sys.path.append(str(pathRoot))

from pydantic import BaseModel, Field
from fairscape_mds.config import get_fairscape_config
from fairscape_mds.models.rocrate import (
    UploadExtractedCrate,
    UploadZippedCrate,
    DeleteExtractedCrate,
    GetMetadataFromCrate,
    ListROCrates,
    StreamZippedROCrate,
    GetROCrateMetadata,
    PublishROCrateMetadata,
    PublishProvMetadata,
    ROCrate,
    ROCrateDistribution
)

from typing import List, Dict, Optional
from uuid import UUID, uuid4


# setup logging
logging.basicConfig(stream=sys.stdout, level=logging.INFO)
backgroundTaskLogger = logging.getLogger("workerLogger")

# setup clients
fairscapeConfig = get_fairscape_config()
brokerURL = fairscapeConfig.redis.getBrokerURL()

mongoClient = fairscapeConfig.CreateMongoClient()
mongoDB = mongoClient[fairscapeConfig.mongo.db]
rocrateCollection = mongoDB[fairscapeConfig.mongo.rocrate_collection]
identifierCollection = mongoDB[fairscapeConfig.mongo.identifier_collection]
userCollection = mongoDB[fairscapeConfig.mongo.user_collection]
asyncCollection = mongoDB[fairscapeConfig.mongo.async_collection]

minioConfig= fairscapeConfig.minio
minioClient = fairscapeConfig.CreateMinioClient()


celeryApp = Celery()
celeryApp.conf.broker_url = brokerURL

def serializeTimestamp(time):
    if time:
        return time.timestamp()
    else:
        return None

class ROCrateUploadJob(BaseModel):
    transactionFolder: str
    zippedCratePath: str
    timeStarted: datetime.datetime | None = Field(default=None)
    timeFinished: datetime.datetime | None = Field(default=None)
    status: Optional[str] = Field(default='in progress')
    completed: Optional[bool] = Field(default=False)
    success: Optional[bool] = Field(default=False)
    processedFiles: List[str] = Field(default=[])
    identifiersMinted: List[str] = Field(default=[])
    error: str | None = Field(default=None)


def createUploadJob(
        transactionFolder: str, 
        zippedCratePath: str,
        ):
    ''' Insert a record into mongo for the submission of a job.

    Keyword arguments:
    transactionFolder -- (str) the UUID representing the unique path in minio
    zippedCratePath   -- (str) the filename of the zipped crate contents
    '''

    # setup job model
    uploadJobInstance = ROCrateUploadJob(
        transactionFolder=transactionFolder,
        zippedCratePath=zippedCratePath,
        timeStarted= datetime.datetime.now(tz=datetime.timezone.utc)
    )

    insertResult = asyncCollection.insert_one(
            uploadJobInstance.model_dump()
            )

    return uploadJobInstance 


def getUploadJob(
        transactionFolder: str,
    ):
    ''' Return a upload Job record from mongo by the job UUID generated by celery.

    Keyword arguments:
    transactionFolder -- (str) the UUID representing the unique path in minio
    zippedCratePath   -- (str) the filename of the zipped crate contents
    '''

    jobMetadata = asyncCollection.find_one(
        {"transactionFolder": transactionFolder},
        { "_id": 0}
    )

    if jobMetadata:
        return ROCrateUploadJob.model_validate(jobMetadata)
    else:
        return None


def updateUploadJob(transactionFolder: str, update: Dict):
    ''' Update async job using the transactionFolder as the primary key

    Keyword arguments:
    transactionFolder -- (str) the UUID representing the job
    update            -- (Dict) the update representing the dictionary
    '''

    # update job with extracted status status
    asyncCollection.update_one(
            {
                "transactionFolder": transactionFolder,
                }, 
            {"$set": update}
            )

@celeryApp.task(name='async-register-ro-crate')
def AsyncRegisterROCrate(transactionFolder: str, filePath: str):
    ''' Background task for processing Zipped ROCrates.

    Keyword arguments:
    transactionFolder -- (str) the UUID representing the unique path in minio
    zippedCratePath   -- (str) the filename of the zipped crate contents
    '''

    backgroundTaskLogger.info(
            f"transaction: {str(transactionFolder)}\tmessage: init background rocrate processing"
            )


    try:
        objectResponse = minioClient.get_object(
            bucket_name=fairscapeConfig.minio.rocrate_bucket, 
            object_name=filePath
            )
        zippedContent = objectResponse.read()

    except Exception as minioException:
        backgroundTaskLogger.error(
                f"transaction: {str(transactionFolder)}" +
                "\tmessage: failed to read minio object" + f"\terror: {str(minioException)}"
                )

        updateUploadJob(
                transactionFolder, 
                {
                    "completed": True,
                    "success": False,
                    "error": f"Failed to read minio Object \terror: {str(minioException)}"
                    }
                )


        return False

    finally:
        objectResponse.close()
        objectResponse.release_conn()


    backgroundTaskLogger.info(
            f"transaction: {str(transactionFolder)}\tmessage: read zipped rocrate object from minio"
            )
    
    # upload extracted crate to minio
    extractStatus, extractedFileList = UploadExtractedCrate(
            minioClient,
            io.BytesIO(zippedContent),
            fairscapeConfig.minio.default_bucket,
            transactionFolder
            )

    if not extractStatus.success:
        backgroundTaskLogger.error(
            f"transaction: {str(transactionFolder)}" +
            "\tmessage: uploaded extracted rocrate to minio" +
            f"\terror: {extractStatus.message}"
            )
        updateUploadJob(
                transactionFolder, 
                {
                    "completed": True,
                    "success": False,
                    "error": f"Failed to extract rocrate\terror: {extractStatus.message}"
                    }
                )
        return False

    # update job with extracted status status
    updateUploadJob(
        transactionFolder,
        {
            "processedFiles": extractedFileList,
            "status": "processing metadata"
            }
        )

    backgroundTaskLogger.info(
            f"transaction: {str(transactionFolder)}\tmessage: uploaded extracted rocrate to minio"
            )

    crateDistribution = ROCrateDistribution(
        extractedROCrateBucket = fairscapeConfig.minio.default_bucket,
        archivedROCrateBucket = fairscapeConfig.minio.rocrate_bucket,
        extractedObjectPath = extractedFileList,
        archivedObjectPath =  filePath   
        )

    # validate metadata
    try:
        crateMetadata = GetMetadataFromCrate(
            MinioClient=minioClient, 
            BucketName=fairscapeConfig.minio.default_bucket,
            TransactionFolder=transactionFolder,
            CratePath=pathlib.Path(filePath).stem, 
            Distribution = crateDistribution
            )
    except Exception as e:
        
        errorLog = f"transaction: {str(transactionFolder)}\t" +
                "message: error retreiving rocrate metadata from crate\t" +
                f"error: {str(e)}"
        backgroundTaskLogger.error(errorLog)

        # update the async record
        updateUploadJob(
                transactionFolder,
                {
                    "completed": True,
                    "success": False,
                    "error": errorLog
                    }
                )

        return False

    

    # mint identifiers
    provMetadataMinted = PublishProvMetadata(crateMetadata, identifierCollection)

    if not provMetadataMinted:
        errorLog = f"transaction: {str(transactionFolder)}\t" +
                "message: error minting prov identifiers"
        backgroundTaskLogger.error(errorLog)
    
        # update the uploadJob record
        updateUploadJob(
                transactionFolder,
                {
                    "completed": True,
                    "success": False,
                    "error": errorLog
                    }
                )

        # kill the task
        return False

    updateUploadJob(
            transactionFolder,
            {
                "status": "minting identifiers",
                "identifiersMinted": [ elem.get("@id") for elem in crateMetadata['@graph'] ] + [crateMetadata['@id']]
                }
            )

    rocrateMetadataMinted = PublishROCrateMetadata(crateMetadata, rocrateCollection)

    if not rocrateMetadataMinted:
        errorLog = f"transaction: {str(transactionFolder)}\t" +
                "message: error minting rocrate identifiers"
        backgroundTaskLogger.error(errorLog)

        # update job record
        updateUploadJob(
                transactionFolder,
                {
                    "completed": True,
                    "success": False,
                    "error": errorLog
                    }
                )

        # kill the task
        return False

    backgroundTaskLogger.info(
            f"transaction: {str(transactionFolder)}\t" +
            "message: task succeeded"
            )
    
    updateUploadJob(
            transactionFolder,
            {
                "status": "Finished",
                "timeFinished": datetime.datetime.now(tz=datetime.timezone.utc)
                "completed": True
                "success": True
                }

            )
 
    # mark task as sucessfull
    return True



if __name__ == '__main__':
    args = ['worker', '--loglevel=INFO']
    celeryApp.worker_main(argv=args)

